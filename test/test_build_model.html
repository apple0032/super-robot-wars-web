<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>Export SD Unicorn to GLB</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
        }
        button {
            background: #ff0033;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 0, 51, 0.5);
        }
        button:hover { background: #cc0029; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui-container">
        <button id="downloadBtn">ğŸ’¾ ä¸‹è¼‰æ¨¡å‹ (.glb)</button>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // å¼•å…¥ GLTF å°å‡ºå™¨
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

        // --- 1. å ´æ™¯è¨­ç½® ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222); // äº®ä¸€é»çš„èƒŒæ™¯æ–¹ä¾¿æª¢æŸ¥æ¨¡å‹
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(6, 4, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.5, 0);

        // ç‡ˆå…‰ (åªç‚ºäº†é è¦½ï¼Œä¸æœƒè¢«å°å‡º)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // --- 2. æ§‹å»ºæ¨¡å‹ (èˆ‡ä¹‹å‰ç›¸åŒ) ---
        // æè³ªå®šç¾©
        const matArmor = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4, metalness: 0.1, name: "Armor_White" });
        const matPsychoFrame = new THREE.MeshStandardMaterial({ 
            color: 0xff0000, emissive: 0xff0033, emissiveIntensity: 1.5, roughness: 0.2, metalness: 0.8, name: "Psycho_Frame"
        });
        const matJoint = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, name: "Joint_Grey" });
        const matDarkBlue = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, roughness: 0.5, name: "Backpack_Blue" });
        const matGold = new THREE.MeshStandardMaterial({ color: 0xffcc00, metalness: 0.8, roughness: 0.2, name: "Antenna_Gold" });
        const matGrey = new THREE.MeshStandardMaterial({ color: 0x888888, name: "Weapon_Grey" });

        function createBox(w, h, d, mat, x, y, z, parent) {
            const geom = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(x, y, z);
            if(parent) parent.add(mesh);
            return mesh;
        }

        function buildSDUnicorn() {
            const root = new THREE.Group();
            root.name = "SD_Unicorn_Gundam"; // è¨­å®šæ¨¡å‹åç¨±

            // é€™è£¡é‡è¤‡ä¹‹å‰çš„æ§‹å»ºé‚è¼¯ (ç°¡åŒ–ç‰ˆç¤ºæ„ï¼Œç¢ºä¿çµæ§‹å®Œæ•´)
            // === éª¨ç›† ===
            const pelvis = createBox(1, 0.8, 0.8, matArmor, 0, 1.2, 0, root);
            const skirtL = createBox(0.45, 0.6, 0.2, matArmor, 0.26, -0.1, 0.5, pelvis); skirtL.rotation.x = -0.2;
            const skirtR = createBox(0.45, 0.6, 0.2, matArmor, -0.26, -0.1, 0.5, pelvis); skirtR.rotation.x = -0.2;
            createBox(0.2, 0.4, 0.05, matPsychoFrame, 0, 0, 0.1, skirtL);
            createBox(0.2, 0.4, 0.05, matPsychoFrame, 0, 0, 0.1, skirtR);

            // === èº«é«” ===
            const torsoGroup = new THREE.Group(); torsoGroup.position.set(0, 0.4, 0); pelvis.add(torsoGroup);
            createBox(0.7, 0.6, 0.6, matPsychoFrame, 0, 0.3, 0, torsoGroup);
            const chest = createBox(1.1, 0.7, 0.9, matArmor, 0, 0.8, 0, torsoGroup);
            createBox(0.4, 0.5, 0.1, matDarkBlue, 0, 0.1, 0.46, chest);
            createBox(0.2, 0.3, 0.2, matPsychoFrame, 0.3, 0.1, 0.4, chest);
            createBox(0.2, 0.3, 0.2, matPsychoFrame, -0.3, 0.1, 0.4, chest);
            createBox(0.6, 0.1, 0.6, matGold, 0, 0.4, 0, chest);

            // === é ­éƒ¨ ===
            const headGroup = new THREE.Group(); headGroup.position.set(0, 1.4, 0); chest.add(headGroup);
            createBox(1.3, 1.1, 1.3, matArmor, 0, 0.55, 0, headGroup);
            const face = createBox(0.7, 0.5, 0.2, matGrey, 0, 0.3, 0.6, headGroup);
            createBox(0.6, 0.15, 0.05, new THREE.MeshBasicMaterial({ color: 0x00ff00 }), 0, 0.1, 0.1, face);
            createBox(0.2, 0.2, 0.2, matPsychoFrame, 0, -0.2, 0.1, face);
            createBox(0.2, 0.4, 0.8, matPsychoFrame, 0.7, 0.4, 0.2, headGroup);
            createBox(0.2, 0.4, 0.8, matPsychoFrame, -0.7, 0.4, 0.2, headGroup);
            
            const vFinGroup = new THREE.Group(); vFinGroup.position.set(0, 1.1, 0.6); headGroup.add(vFinGroup);
            createBox(0.3, 0.3, 0.3, matArmor, 0, 0, 0, vFinGroup);
            const finL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.8, 0.2), matGold);
            finL.geometry.translate(0, 0.9, 0); finL.rotation.z = Math.PI / 4.5; vFinGroup.add(finL);
            const finR = finL.clone(); finR.rotation.z = -Math.PI / 4.5; vFinGroup.add(finR);

            // === æ‰‹è‡‚ ===
            function createArm(isRight) {
                const armGroup = new THREE.Group(); const sign = isRight ? 1 : -1;
                armGroup.position.set(sign * 0.8, 0.6, 0);
                const shoulder = new THREE.Group(); armGroup.add(shoulder);
                createBox(0.9, 0.7, 0.9, matPsychoFrame, 0, 0.2, 0, shoulder);
                createBox(1.0, 0.2, 1.0, matArmor, 0, 0.5, 0, shoulder);
                createBox(0.3, 0.6, 1.0, matArmor, sign * 0.4, 0.1, 0, shoulder);
                createBox(0.4, 0.5, 0.4, matArmor, 0, -0.4, 0, armGroup);
                const forearm = createBox(0.6, 0.7, 0.6, matArmor, 0, -1.0, 0, armGroup); forearm.name = 'forearm';
                createBox(0.3, 0.5, 0.1, matPsychoFrame, 0, 0, 0.3, forearm);
                const hand = createBox(0.4, 0.4, 0.4, matJoint, 0, -1.5, 0, armGroup); hand.name = 'hand';
                return armGroup;
            }
            const armL = createArm(false); chest.add(armL);
            const armR = createArm(true); chest.add(armR);

            // === è…¿éƒ¨ ===
            function createLeg(isRight) {
                const legGroup = new THREE.Group(); const sign = isRight ? 1 : -1;
                legGroup.position.set(sign * 0.4, -0.4, 0);
                createBox(0.5, 0.5, 0.5, matArmor, 0, -0.3, 0, legGroup);
                const shinGroup = new THREE.Group(); shinGroup.position.y = -0.8; legGroup.add(shinGroup);
                createBox(0.7, 0.9, 0.8, matPsychoFrame, 0, -0.2, 0, shinGroup);
                createBox(0.5, 0.4, 0.2, matArmor, 0, 0.2, 0.5, shinGroup);
                createBox(0.8, 0.6, 0.9, matArmor, 0, -0.4, 0, shinGroup);
                const foot = new THREE.Group(); foot.position.y = -1.0; shinGroup.add(foot);
                createBox(0.8, 0.4, 1.2, matDarkBlue, 0, 0, 0.1, foot);
                createBox(0.6, 0.3, 0.8, matArmor, 0, 0.3, 0, foot);
                return legGroup;
            }
            const legL = createLeg(false); pelvis.add(legL);
            const legR = createLeg(true); pelvis.add(legR);

            // === èƒŒåŒ… & æ­¦å™¨ (çœç•¥è©³ç´°æ§‹å»ºï¼Œç¢ºä¿æœ‰çµæ§‹å³å¯) ===
            const backpack = new THREE.Group(); backpack.position.set(0, 0.8, -0.5); chest.add(backpack);
            createBox(1.0, 0.8, 0.6, matDarkBlue, 0, 0, 0, backpack);
            
            // æ§
            const gunGroup = new THREE.Group();
            createBox(0.2, 0.4, 1.0, matGrey, 0, 0, 0, gunGroup);
            const rightHand = armR.getObjectByName('hand');
            if(rightHand) { rightHand.add(gunGroup); gunGroup.position.set(0, -0.3, 0.6); gunGroup.rotation.x = -0.2; }

            // ç›¾
            const shieldGroup = new THREE.Group();
            createBox(0.4, 0.6, 0.2, matArmor, 0, 0, 0, shieldGroup);
            createBox(0.2, 0.2, 0.25, matPsychoFrame, 0, 0, 0, shieldGroup); // X-frame placeholder
            const leftForearm = armL.getObjectByName('forearm');
            if(leftForearm) { leftForearm.add(shieldGroup); shieldGroup.position.set(0.6, 0, 0); shieldGroup.rotation.y = -Math.PI/2; }

            return root;
        }

        const gundam = buildSDUnicorn();
        scene.add(gundam);

        // --- 3. å°å‡ºåŠŸèƒ½ (Export Logic) ---
        function exportGLTF(input) {
            const exporter = new GLTFExporter();
            const options = {
                trs: false,
                onlyVisible: true,
                truncateDrawRange: true,
                binary: true, // é‡è¦ï¼šè¨­ç‚º true æœƒå°å‡ºå–®ä¸€ .glb æª”æ¡ˆ
            };

            exporter.parse(
                input,
                function (result) {
                    if (result instanceof ArrayBuffer) {
                        saveArrayBuffer(result, 'sd_unicorn.glb');
                    } else {
                        const output = JSON.stringify(result, null, 2);
                        saveString(output, 'sd_unicorn.gltf');
                    }
                },
                function (error) {
                    console.log('An error happened during export:', error);
                },
                options
            );
        }

        const link = document.createElement('a');
        link.style.display = 'none';
        document.body.appendChild(link);

        function save(blob, filename) {
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        function saveArrayBuffer(buffer, filename) {
            save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
        }

        // ç¶å®šæŒ‰éˆ•
        document.getElementById('downloadBtn').addEventListener('click', function() {
            exportGLTF(gundam);
        });

        // æ¸²æŸ“å¾ªç’°
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>