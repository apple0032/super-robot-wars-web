<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>SRW Web Game (Topdown Height Fixed)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <style>
        *, *::before, *::after { box-sizing: border-box; }

        body {
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background-color: #202020;
            color: white;
            display: flex;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1;
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 10;
        }

        #ui-panel {
            position: absolute; right: 0; top: 0; width: 340px;
            height: 100vh;
            background-color: rgba(30, 30, 30, 0.95); padding: 15px;
            display: flex; flex-direction: column; border-left: 2px solid #444;
            pointer-events: auto; color: white; overflow-y: auto;
        }

        .game-logo {
            display: block;
            max-width: 100%;
            height: auto;
            margin: 0 auto 15px auto;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
        }

        .control-group { display: flex; flex-direction: column; gap: 8px; margin-bottom: 8px; }
        .control-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: #ccc; }
        .control-row span { flex: 1; }
        input[type=range] { width: 55%; cursor: pointer; }
        input[type=checkbox] { cursor: pointer; transform: scale(1.2); margin-right: 10px;}
        .btn-small { padding: 4px 8px; background: #555; border: 1px solid #777; color: white; cursor: pointer; font-size: 12px; border-radius: 4px; }
        .btn-small:hover { background: #777; }

        #turn-banner {
            position: absolute; top: 40%; left: -100%; width: 100%; height: 100px;
            background: rgba(0, 0, 0, 0.85); color: white;
            display: flex; justify-content: center; align-items: center;
            font-size: 48px; font-weight: bold; font-style: italic; 
            border-top: 2px solid #fff; border-bottom: 2px solid #fff;
            transition: left 0.5s ease-out; pointer-events: none;
            padding-right: 340px; 
        }

        #action-menu {
            position: absolute; display: none; width: 200px;
            background-color: rgba(30, 30, 30, 0.95);
            border: 1px solid #666; border-radius: 8px; padding: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.8);
            backdrop-filter: blur(4px); pointer-events: auto; z-index: 5000;
        }
        #action-menu h3 { margin: 0 0 8px 0; font-size: 14px; text-align: center; color: #ffd700; border-bottom: 1px solid #555; padding-bottom: 5px; }
        #action-menu .btn { padding: 10px; margin: 4px 0; font-size: 14px; border-radius: 4px; width: 100%; text-align: left; cursor: pointer; color: white; border: 1px solid #666; background: #444; pointer-events: auto; }
        .btn-move { background-color: #28a745; border-left: 5px solid #1e7e34; }
        .btn-action { background-color: #2d5a88; border-left: 5px solid #4da6ff; }
        .btn-cancel { background-color: #442222; border-color: #663333; }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .overlay-label { position: absolute; transform: translate(-50%, -50%); pointer-events: none; white-space: nowrap; }
        .hp-bar-container { width: 40px; height: 6px; background: #333; border: 1px solid #000; }
        .hp-bar-fill { height: 100%; background: #0f0; width: 100%; transition: width 0.5s ease-out; }

        .damage-popup { color: #ff3333; font-size: 28px; font-weight: 900; text-shadow: 2px 2px 0px #000; animation: float-up 1s forwards; }
        .miss-popup { color: #4da6ff; font-size: 28px; font-weight: 900; text-shadow: 2px 2px 0px #000; animation: float-up 1s forwards; }
        .sword-icon-popup { font-size: 40px; animation: icon-pop 0.6s forwards; }

        @keyframes float-up { 0% { transform: translate(-50%, 0) scale(0.5); opacity: 1; } 100% { transform: translate(-50%, -50px) scale(1); opacity: 0; } }
        @keyframes icon-pop { 0% { transform: translate(-50%, 0) scale(0); opacity: 0; } 30% { transform: translate(-50%, 0) scale(1.5); opacity: 1; } 100% { transform: translate(-50%, 0) scale(1); opacity: 0; } }

        h2, h3 { margin-top: 0; color: #ffd700; text-align: center;}
        .info-box { background: #333; padding: 12px; margin-bottom: 15px; border-radius: 8px; border: 1px solid #444; }
        
        .btn-end { background-color: #3d6aa8; text-align: center; font-weight: bold; margin-top: auto; padding: 15px; font-size: 18px; width: 100%; cursor: pointer; color: white; border: 1px solid #666; pointer-events: auto; transition: background-color 0.3s; }
        .btn-end:hover { background-color: #4a7bc0; } 
        .btn-end:disabled { cursor: not-allowed; opacity: 0.8; }
        .btn-restart { background-color: #228b22; text-align: center; font-weight: bold; padding: 15px; font-size: 18px; display: none; margin-top: auto; width: 100%; cursor: pointer; color: white; border: 1px solid #666; pointer-events: auto;}
        
        #log { flex: 1; background: #111; border: 1px solid #444; padding: 10px; overflow-y: auto; font-family: Consolas, monospace; font-size: 13px; color: #ddd; margin-bottom: 10px; border-radius: 4px; pointer-events: auto; }
        .log-entry { margin-bottom: 6px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-damage { color: #ff6b6b; font-weight: bold; }
        .log-system { color: #ffff00; }
        .log-miss { color: #4da6ff; font-weight: bold; font-style: italic;}
        .log-counter { color: #ff9900; font-weight: bold; }

        .explosion-container { position: absolute; width: 0; height: 0; pointer-events: none; z-index: 200; }
        .exp-particle { position: absolute; top: 0; left: 0; width: 8px; height: 8px; background-color: #ffcc00; border-radius: 50%; box-shadow: 0 0 10px #ff6600; animation: particle-anim 0.8s ease-out forwards; }
        .exp-flash { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 10px; height: 10px; background: white; border-radius: 50%; box-shadow: 0 0 20px 10px white; animation: flash-anim 0.4s ease-out forwards; z-index: 201; }
        @keyframes particle-anim { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; } }
        @keyframes flash-anim { 0% { transform: translate(-50%, -50%) scale(1); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(8); opacity: 0; } }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div id="ui-layer">
    <div id="turn-banner">PLAYER PHASE</div>

    <div id="action-menu">
        <h3>è¡Œå‹•æŒ‡ä»¤</h3>
        <button class="btn btn-move" id="btn-move" onclick="playClick(); activateMovePhase()">ğŸƒ ç§»å‹•</button>
        <button class="btn btn-action" id="btn-melee" onclick="playClick(); selectWeapon('melee')">âš”ï¸ æ ¼é¬¥ (å°„ç¨‹1)<br><span style="font-size:11px;color:#ccc">å‚·å®³:50-70 | å‘½ä¸­:60-70%</span></button>
        <button class="btn btn-action" id="btn-range" onclick="playClick(); selectWeapon('range')">ğŸ”« å°„æ“Š (å°„ç¨‹2-4)<br><span style="font-size:11px;color:#ccc">å‚·å®³:40-60 | å‘½ä¸­:50-60%<br><span style="color:#ff6666">(ç§»å‹•å¾Œä¸å¯ç”¨)</span></span></button>
        <button class="btn" onclick="playClick(); waitAction()">âœ‹ å¾…å‘½</button>
        <button class="btn btn-cancel" id="btn-cancel" onclick="playClick(); cancelMove()">â†© å–æ¶ˆ</button>
    </div>

    <div id="ui-panel">
        <img src="assets/banner.png" class="game-logo" alt="SRW 3D">
        
        <div class="info-box" id="turn-indicator">
            ç¾åœ¨å›åˆ: <span id="turn-text" style="color: #4da6ff; font-weight: bold;">ç©å®¶å›åˆ</span>
            <div style="margin-top:8px; border-top:1px solid #555; padding-top:5px; font-size:16px; color:#fff;">
                å›åˆæ•¸ç›®: <span id="turn-count" style="color:#ffd700; font-weight:bold;">1</span>
            </div>
        </div>
        <div class="info-box" id="unit-stats">
            <h3 style="margin:0 0 10px 0; font-size:16px;">æ©Ÿé«”è³‡è¨Š</h3>
            <div id="stats-content">è«‹é¸æ“‡æ©Ÿé«”</div>
        </div>
        <div id="log"></div>

        <div class="info-box">
            <h3 id="settings-header" style="margin-bottom:10px; cursor: pointer; user-select: none;" onclick="toggleSettings()">â–¼ ç³»çµ±è¨­å®š</h3>
            <div id="settings-body">
                <div class="control-group">
                    <div class="control-row">
                        <span>ğŸ’¡ äº®åº¦</span>
                        <input type="range" id="light-slider" min="0.5" max="3" step="0.1" value="0.5" oninput="updateLight()">
                    </div>
                    <div class="control-row">
                        <span>ğŸ” ç¸®æ”¾</span>
                        <input type="range" id="cam-zoom" min="50" max="800" step="5" value="140" oninput="updateSystemSettings()">
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-row">
                        <span>â†”ï¸ åœ°åœ–ä½ç½® X</span>
                        <input type="range" id="map-pan-x" min="-500" max="500" step="0.1" value="30" oninput="updateMapPosition()">
                    </div>
                    <div class="control-row">
                        <span>â†•ï¸ åœ°åœ–ä½ç½® Z</span>
                        <input type="range" id="map-pan-z" min="-500" max="500" step="0.1" value="15" oninput="updateMapPosition()">
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-row">
                        <span>ğŸ”„ æ—‹è½‰</span>
                        <input type="range" id="cam-rotate" min="0" max="360" step="1" value="0" oninput="updateSystemSettings()">
                    </div>
                    <div class="control-row">
                        <button class="btn-small" onclick="resetCamera('north')">â¬†ï¸ æ­£åŒ—</button>
                        <button class="btn-small" onclick="resetCamera('topdown')">ğŸ¦… é³¥ç°</button>
                    </div>
                    <div class="control-row">
                        <span>â†•ï¸ é«˜åº¦</span>
                        <input type="range" id="cam-height" min="50" max="600" step="10" value="200" oninput="updateSystemSettings()">
                    </div>
                </div>
                <div style="border-top:1px solid #555; margin: 5px 0;"></div>
                <div class="control-group">
                    <div class="control-row">
                        <span>â¤ï¸ è¡€æ¢é¡¯ç¤º</span>
                        <input type="checkbox" id="hp-toggle" onchange="toggleHPBars()">
                    </div>
                </div>
                <div style="border-top:1px solid #555; margin: 5px 0;"></div>
                <div class="control-group">
                    <div class="control-row">
                        <span>ğŸµ éŸ³æ¨‚</span>
                        <input type="checkbox" id="bgm-toggle" checked onchange="toggleBGM()">
                    </div>
                    <div class="control-row">
                        <span>ğŸ”Š éŸ³æ•ˆ</span>
                        <input type="checkbox" id="sfx-toggle" checked onchange="toggleSFX()">
                    </div>
                    <div class="control-row">
                        <span>ğŸ”Š éŸ³é‡</span>
                        <input type="range" id="vol-slider" min="0" max="1" step="0.1" value="0.7" oninput="updateAudioVolume()">
                    </div>
                </div>
            </div>
        </div>

        <button class="btn-end" id="btn-end-turn" onclick="playClick(); endTurn()">çµæŸå›åˆ</button>
        <button class="btn-restart" id="btn-restart" onclick="playClick(); restartGame()">é‡æ–°éŠæˆ²</button>
    </div>
    
    <div id="overlay-container"></div>
</div>

<script>
    // --- 3D è®Šæ•¸ ---
    let scene, camera, renderer, raycaster, mouse;
    let ambientLight; 
    let gridMeshes = []; 
    let unitMeshes = {}; 
    let hoverCursor; 
    let glowMeshes = []; 
    const TILE_SIZE = 10; 
    const BOARD_SIZE = 18;
    const MAP_WIDTH = BOARD_SIZE * TILE_SIZE;
    const MAP_HEIGHT = BOARD_SIZE * TILE_SIZE;
    const WORLD_OFFSET_X = - (BOARD_SIZE * TILE_SIZE) / 2 + TILE_SIZE / 2;
    const WORLD_OFFSET_Z = - (BOARD_SIZE * TILE_SIZE) / 2 + TILE_SIZE / 2;

    let cameraTarget = new THREE.Vector3(30, 0, 15); 
    let isDraggingMap = false;
    let dragStartPoint = { x: 0, y: 0 };
    let dragStartTarget = new THREE.Vector3();

    // éš¨æ©Ÿè¼‰å…¥åœ°åœ–
    const textureLoader = new THREE.TextureLoader();
    const mapFiles = ['map1.png', 'map2.png', 'map3.png', 'map4.png', 'map5.png'];
    const randomMapIndex = Math.floor(Math.random() * mapFiles.length);
    const selectedMapFile = mapFiles[randomMapIndex];
    const mapPath = 'assets/map/' + selectedMapFile;
    console.log("Loading Map:", mapPath); 

    const mapTexture = textureLoader.load(mapPath, (texture) => {
        texture.magFilter = THREE.NearestFilter;
        texture.minFilter = THREE.NearestFilter;
    });

    // --- éŠæˆ²è®Šæ•¸ ---
    const UNIT_HP = 100;
    const MOVE_RANGE = 5;
    const TEAM_PLAYER = 'player';
    const TEAM_ENEMY = 'enemy';
    let units = [];
    let currentTurn = TEAM_PLAYER;
    let selectedUnit = null;
    let originalPos = null;
    let gameState = 'TRANSITION';
    let turnCount = 1;
    let gridHeights = []; 
    let isHPVisible = false;

    // --- éŸ³æ•ˆ ---
    let isBGMEnabled = true;
    let isSFXEnabled = true; 
    let masterVolume = 0.7; 
    const sfxAttack = new Audio('sounds/attack.mp3');
    const sfxLaser = new Audio('sounds/laser.mp3');
    const sfxExplosion = new Audio('sounds/explosion.mp3');
    const sfxClick = new Audio('sounds/click.mp3');
    const bgmPlayer = new Audio('sounds/player.mp3'); bgmPlayer.loop = true; 
    const bgmEnemy = new Audio('sounds/enemy.mp3'); bgmEnemy.loop = true; 
    let currentBGM = null;

    // --- ç³»çµ±æ§åˆ¶ ---
    function playClick() {
        if (!isSFXEnabled) return;
        sfxClick.volume = masterVolume;
        sfxClick.currentTime = 0;
        sfxClick.play().catch(e=>{});
    }

    function toggleSettings() {
        const body = document.getElementById('settings-body');
        const header = document.getElementById('settings-header');
        playClick();
        if (body.style.display === 'none') {
            body.style.display = 'block';
            header.innerText = 'â–¼ ç³»çµ±è¨­å®š';
        } else {
            body.style.display = 'none';
            header.innerText = 'â–¶ ç³»çµ±è¨­å®š';
        }
    }

    function toggleHPBars() {
        const checkbox = document.getElementById('hp-toggle');
        isHPVisible = checkbox.checked;
        const allBars = document.querySelectorAll('.hp-overlay');
        allBars.forEach(el => {
            if (isHPVisible) {
                if(el.hideTimer) clearTimeout(el.hideTimer);
                el.style.display = 'block';
            } else {
                el.style.display = 'none';
            }
        });
    }

    function toggleSFX() {
        const checkbox = document.getElementById('sfx-toggle');
        isSFXEnabled = checkbox.checked;
    }

    function updateLight() {
        if (!ambientLight) return;
        const lightVal = parseFloat(document.getElementById('light-slider').value);
        ambientLight.intensity = lightVal;
    }

    function updateMapPosition() {
        const x = parseFloat(document.getElementById('map-pan-x').value);
        const z = parseFloat(document.getElementById('map-pan-z').value);
        cameraTarget.x = x;
        cameraTarget.z = z;
        updateSystemSettings();
    }

    function updateSystemSettings() {
        if (!camera) return;
        
        const angle = parseFloat(document.getElementById('cam-rotate').value);
        const height = parseFloat(document.getElementById('cam-height').value);
        const radius = parseFloat(document.getElementById('cam-zoom').value);

        const rad = (angle + 90) * Math.PI / 180;

        const offsetX = Math.cos(rad) * radius;
        const offsetZ = Math.sin(rad) * radius;

        camera.position.x = cameraTarget.x + offsetX;
        camera.position.z = cameraTarget.z + offsetZ;
        camera.position.y = height;
        
        camera.lookAt(cameraTarget);
    }

    // --- [ä¿®æ”¹] é‡ç½®ç›¸æ©Ÿé‚è¼¯ï¼šé³¥ç°æ™‚è¨­å®šé«˜åº¦ç‚º260 ---
    function resetCamera(mode) {
        playClick();
        let newX = 0, newZ = 0;
        if (mode === 'north') {
            document.getElementById('cam-rotate').value = 0;
            document.getElementById('cam-height').value = 200;
            document.getElementById('cam-zoom').value = 140; 
            newX = 30; newZ = 15; 
        } else if (mode === 'topdown') {
            document.getElementById('cam-rotate').value = 0;
            document.getElementById('cam-height').value = 260; // ç¡¬ç·¨ç¢¼ç‚º260
            document.getElementById('cam-zoom').value = 10;
            newX = 0; newZ = 0;
        }
        
        cameraTarget.set(newX, 0, newZ);
        document.getElementById('map-pan-x').value = newX;
        document.getElementById('map-pan-z').value = newZ;
        
        updateSystemSettings();
    }

    function toggleBGM() {
        const checkbox = document.getElementById('bgm-toggle');
        isBGMEnabled = checkbox.checked;
        if (!isBGMEnabled && currentBGM) {
            currentBGM.pause();
        } else if (isBGMEnabled && currentBGM) {
            currentBGM.play().catch(e=>{});
        }
    }

    function updateAudioVolume() {
        const val = parseFloat(document.getElementById('vol-slider').value);
        masterVolume = val;
        bgmPlayer.volume = masterVolume;
        bgmEnemy.volume = masterVolume;
        sfxAttack.volume = masterVolume;
        sfxLaser.volume = masterVolume;
        sfxExplosion.volume = masterVolume;
        sfxClick.volume = masterVolume;
        if(currentBGM) currentBGM.volume = masterVolume;
    }

    function playSound(audio) {
        if (!isSFXEnabled) return; 
        audio.volume = masterVolume; 
        audio.currentTime = 0;
        audio.play().catch(e=>{});
    }

    function switchBGM(type) {
        if (currentBGM) {
            currentBGM.pause();
            currentBGM.currentTime = 0;
        }
        if (type === 'player') currentBGM = bgmPlayer;
        else if (type === 'enemy') currentBGM = bgmEnemy;
        else currentBGM = null;

        if (isBGMEnabled && currentBGM) {
            currentBGM.volume = masterVolume;
            currentBGM.play().catch(e=>{});
        }
    }

    // --- 3D åˆå§‹åŒ– ---
    function initThreeJS() {
        const container = document.getElementById('canvas-container');
        if (renderer) return;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101010);
        scene.fog = new THREE.Fog(0x101010, 100, 1000);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 3000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        ambientLight = new THREE.AmbientLight(0x808080, 0.5);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Hover æ¸¸æ¨™
        const cursorGeometry = new THREE.BoxGeometry(TILE_SIZE, 0.5, TILE_SIZE);
        const cursorMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffff00,      // é»ƒè‰²
            transparent: true,    // é–‹å•Ÿé€æ˜
            opacity: 0.4,
            depthTest: false,     // ä¸é®æ“‹
            depthWrite: false
        });
        hoverCursor = new THREE.Mesh(cursorGeometry, cursorMaterial);
        hoverCursor.renderOrder = 999;
        hoverCursor.visible = false; 
        scene.add(hoverCursor);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        window.addEventListener('resize', onWindowResize, false);
        
        const canvasEl = renderer.domElement;
        canvasEl.addEventListener('pointerdown', onPointerDown, false);
        window.addEventListener('pointermove', onPointerMove, false);
        window.addEventListener('pointerup', onPointerUp, false);
        canvasEl.addEventListener('wheel', onMouseWheel, { passive: false });

        document.getElementById('map-pan-x').value = cameraTarget.x;
        document.getElementById('map-pan-z').value = cameraTarget.z;
        document.getElementById('cam-rotate').value = 0;
        document.getElementById('cam-zoom').value = 140;
        document.getElementById('light-slider').value = 0.5; // UI åŒæ­¥ç‚º 0.5
        document.getElementById('cam-height').value = 200;
        document.getElementById('vol-slider').value = 0.7;
        document.getElementById('hp-toggle').checked = false;
        document.getElementById('sfx-toggle').checked = true; 
        isHPVisible = false;
        isSFXEnabled = true;

        updateSystemSettings();
        updateAudioVolume();
        animate();
    }

    // --- æ»¾è¼ªç¸®æ”¾ ---
    function onMouseWheel(event) {
        event.preventDefault();
        const zoomInput = document.getElementById('cam-zoom');
        let val = parseFloat(zoomInput.value);
        const sensitivity = 0.2; 
        val += event.deltaY * sensitivity;
        if (val < parseFloat(zoomInput.min)) val = parseFloat(zoomInput.min);
        if (val > parseFloat(zoomInput.max)) val = parseFloat(zoomInput.max);
        zoomInput.value = val;
        updateSystemSettings();
    }

    // --- æ»‘é¼ æ‹–æ›³é‚è¼¯ ---
    function onPointerDown(event) {
        if (event.target.closest('#ui-panel') || event.target.closest('#action-menu')) return;
        isDraggingMap = false;
        dragStartPoint.x = event.clientX;
        dragStartPoint.y = event.clientY;
        dragStartTarget.copy(cameraTarget);
    }

    function onPointerMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        if (event.buttons > 0) {
            const dx = event.clientX - dragStartPoint.x;
            const dy = event.clientY - dragStartPoint.y;
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                isDraggingMap = true;
                document.getElementById('canvas-container').style.cursor = 'grabbing';
            }
            if (isDraggingMap) {
                const angle = parseFloat(document.getElementById('cam-rotate').value);
                const rad = (angle + 90) * Math.PI / 180;
                const zoom = parseFloat(document.getElementById('cam-zoom').value);
                const speed = 0.002 * (zoom / 200);
                const fwdX = -Math.cos(rad);
                const fwdZ = -Math.sin(rad);
                const rightX = -Math.sin(rad); 
                const rightZ = Math.cos(rad);
                
                cameraTarget.x = dragStartTarget.x - (rightX * dx + fwdX * -dy) * speed;
                cameraTarget.z = dragStartTarget.z - (rightZ * dx + fwdZ * -dy) * speed;
                
                document.getElementById('map-pan-x').value = cameraTarget.x;
                document.getElementById('map-pan-z').value = cameraTarget.z;

                updateSystemSettings();
                
                if(hoverCursor) hoverCursor.visible = false;
                return;
            }
        }

        if (!isDraggingMap && hoverCursor && gridMeshes.length > 0) {
            raycaster.setFromCamera(mouse, camera);
            const allGrids = gridMeshes.flat();
            const intersects = raycaster.intersectObjects(allGrids);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                const hx = obj.userData.x;
                const hy = obj.userData.y;
                const topY = 0; 

                const wx = hx * TILE_SIZE + WORLD_OFFSET_X;
                const wz = hy * TILE_SIZE + WORLD_OFFSET_Z;

                hoverCursor.position.set(wx, topY + 0.25, wz);
                hoverCursor.visible = true;
            } else {
                hoverCursor.visible = false;
            }
        }
    }

    function onPointerUp(event) {
        isDraggingMap = false;
        document.getElementById('canvas-container').style.cursor = 'grab';

        if (event.target.closest('#ui-panel') || event.target.closest('#action-menu')) return;
        
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const allGrids = gridMeshes.flat();
        const intersects = raycaster.intersectObjects(allGrids);
        if (intersects.length > 0) {
            const obj = intersects[0].object;
            handleCellClick(obj.userData.x, obj.userData.y);
        } else {
            if (gameState === 'ACTION_SELECT') {
                const hasMoved = (selectedUnit.x !== originalPos.x || selectedUnit.y !== originalPos.y);
                if (!hasMoved) resetState();
            }
        }
    }

    // åœ°åœ–ç”Ÿæˆ
    function createGridMap() {
        gridMeshes.forEach(row => row.forEach(mesh => scene.remove(mesh)));
        gridMeshes = [];
        gridHeights = [];

        log(`åœ°åœ–ä¸»é¡Œ: 2D è²¼åœ–æ¨¡å¼ (${selectedMapFile})`, 'system');

        // 1. å‰µå»ºåº•å±¤åœ°åœ–å¹³é¢
        const mapGeometry = new THREE.PlaneGeometry(MAP_WIDTH, MAP_HEIGHT);
        const mapMaterial = new THREE.MeshPhongMaterial({ 
            map: mapTexture, 
            side: THREE.DoubleSide,
            shininess: 0 
        });
        const mapMesh = new THREE.Mesh(mapGeometry, mapMaterial);
        mapMesh.rotation.x = -Math.PI / 2; 
        mapMesh.position.y = -0.1; 
        mapMesh.receiveShadow = true;
        scene.add(mapMesh);

        // 2. å‰µå»ºé ‚å±¤äº’å‹•ç¶²æ ¼ (é€æ˜)
        for (let y = 0; y < BOARD_SIZE; y++) {
            gridMeshes[y] = [];
            gridHeights[y] = []; 
            for (let x = 0; x < BOARD_SIZE; x++) {
                const geometry = new THREE.PlaneGeometry(TILE_SIZE * 0.98, TILE_SIZE * 0.98);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.0, 
                    side: THREE.DoubleSide,
                    depthWrite: false 
                });
                const plane = new THREE.Mesh(geometry, material);
                
                const wx = x * TILE_SIZE + WORLD_OFFSET_X;
                const wz = y * TILE_SIZE + WORLD_OFFSET_Z;
                
                plane.rotation.x = -Math.PI / 2; 
                plane.position.set(wx, 0.05, wz); 
                
                plane.userData = { x: x, y: y };
                
                scene.add(plane);
                gridMeshes[y][x] = plane;
                gridHeights[y][x] = 0; 
            }
        }
    }

    function logicalToWorld(x, y) {
        const wx = x * TILE_SIZE + WORLD_OFFSET_X;
        const wz = y * TILE_SIZE + WORLD_OFFSET_Z;
        const groundY = gridHeights[y][x]; 
        return { x: wx, y: 0.5, z: wz };
    }

    function toScreenPosition(obj, offsetX = 0, offsetY = 0) {
        const vector = new THREE.Vector3();
        obj.updateMatrixWorld();
        vector.setFromMatrixPosition(obj.matrixWorld);
        vector.y += 8; 
        vector.project(camera);
        const x = (vector.x * .5 + .5) * window.innerWidth + offsetX;
        const y = -(vector.y * .5 - .5) * window.innerHeight + offsetY;
        return { x: x, y: y };
    }

    // --- [ä¿®æ”¹ç‰ˆ] SD æ©Ÿå™¨äººæ¨¡å‹å‡½å¼ (åŒ…å«æ•µæˆ‘é…è‰²å€åˆ† & è¿½æ“Šæ§é…è‰²) ---
    function createRobotModel(color, team) {
        const group = new THREE.Group();
        
        // æè³ªå®šç¾©
        const mainMat = new THREE.MeshPhongMaterial({ color: color });
        const darkMat = new THREE.MeshPhongMaterial({ color: 0x333333 }); 
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        // [æ–°å¢] è¿½æ“Šæ§æè³ªï¼šæ·±å’–å•¡è‰²æ§ç®¡ï¼Œæ·±é»ƒè‰²è¿½æ“Šå™¨
        const gunBarrelMat = new THREE.MeshPhongMaterial({ color: 0x8B4513, shininess: 30 }); // å•¡è‰²
        const gunSensorMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 }); // æ·±é»ƒè‰² (Gold)

        // è¨­å®šå…‰åŠé¡è‰² (æ ¹æ“šéšŠä¼)
        let bladeColor, glowColor;
        if (team === TEAM_PLAYER) {
            bladeColor = 0xccffff; // ç©å®¶ï¼šé’ç™½è‰²æ ¸å¿ƒ
            glowColor = 0x0033ff;  // ç©å®¶ï¼šè—è‰²å…‰æšˆ
        } else {
            bladeColor = 0xffddff; // æ•µäººï¼šç²‰ç™½æ ¸å¿ƒ
            glowColor = 0xff00cc;  // æ•µäººï¼šç²‰ç´…å…‰æšˆ
        }

        // === 1. èº«é«” (Body) - ç¸®å° ===
        const chestGeo = new THREE.BoxGeometry(3.0, 2.5, 2.0); 
        const chest = new THREE.Mesh(chestGeo, mainMat);
        chest.position.y = 3.0; 
        chest.castShadow = true;
        chest.receiveShadow = true;
        chest.userData.isArmor = true;
        group.add(chest);

        // === 2. é ­éƒ¨ (Head) - ç¸®å° ===
        const headGeo = new THREE.BoxGeometry(3.5, 3.0, 3.5); 
        const head = new THREE.Mesh(headGeo, mainMat);
        head.position.y = 5.8; 
        head.castShadow = true;
        head.userData.isArmor = true;
        group.add(head);

        // çœ¼ç›
        const eyeGeo = new THREE.PlaneGeometry(1.2, 1.4);
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-0.8, 5.6, 1.76); 
        group.add(leftEye);
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(0.8, 5.6, 1.76); 
        group.add(rightEye);

        // === 3. è…¿éƒ¨ (Legs) - ç¸®å° ===
        const legGeo = new THREE.BoxGeometry(1.2, 2.0, 1.8);
        const leftLeg = new THREE.Mesh(legGeo, darkMat);
        leftLeg.position.set(-0.8, 1.0, 0);
        leftLeg.castShadow = true;
        const rightLeg = new THREE.Mesh(legGeo, darkMat);
        rightLeg.position.set(0.8, 1.0, 0);
        rightLeg.castShadow = true;
        group.add(leftLeg, rightLeg);

        // === 4. æ‰‹è‡‚ (Arms) - ç¸®å° ===
        const armGeo = new THREE.BoxGeometry(1.2, 2.5, 1.5);
        const leftArm = new THREE.Mesh(armGeo, mainMat);
        leftArm.position.set(-2.2, 3.0, 0);
        leftArm.castShadow = true;
        leftArm.userData.isArmor = true;
        const rightArm = new THREE.Mesh(armGeo, mainMat);
        rightArm.position.set(2.2, 3.0, 0);
        rightArm.castShadow = true;
        rightArm.userData.isArmor = true;
        group.add(leftArm, rightArm);

        // === 5. æ‰‹æŒæ­¦å™¨ (Main Beam Saber) ===
        const mainSwordGroup = new THREE.Group();
        mainSwordGroup.position.set(2.8, 3.0, 1.0);
        mainSwordGroup.rotation.set(Math.PI / 2 + 0.2, 0, Math.PI / 8);
        group.add(mainSwordGroup);

        // åŠæŸ„
        const hiltGeo = new THREE.CylinderGeometry(0.25, 0.25, 2.0, 8); 
        const hilt = new THREE.Mesh(hiltGeo, darkMat);
        hilt.position.set(0, -1.0, 0); 
        mainSwordGroup.add(hilt);

        // å…‰åŠæ ¸å¿ƒ (ä½¿ç”¨åˆ¤æ–·å¾Œçš„é¡è‰²)
        const bladeGeo = new THREE.CylinderGeometry(0.2, 0.2, 6.0, 8); 
        const bladeMat = new THREE.MeshBasicMaterial({ color: bladeColor }); 
        const blade = new THREE.Mesh(bladeGeo, bladeMat);
        blade.position.set(0, 3.0, 0); 
        mainSwordGroup.add(blade);

        // å…‰åŠå…‰æšˆ (ä½¿ç”¨åˆ¤æ–·å¾Œçš„é¡è‰²)
        const glowGeo = new THREE.CylinderGeometry(0.6, 0.6, 6.5, 8); 
        const glowMat = new THREE.MeshBasicMaterial({ 
            color: glowColor, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, depthWrite: false 
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        glow.position.set(0, 3.0, 0);
        mainSwordGroup.add(glow);
        glowMeshes.push(glow); 

        // === 6. èƒŒéƒ¨è¿½æ“Šæ§ (Pursuit Gun) - [ä¿®æ”¹] å¥—ç”¨æ–°æè³ª ===
        // èƒŒåŒ…æ›æ¶
        const backpackGeo = new THREE.BoxGeometry(1.8, 2.4, 1.2);
        const backpack = new THREE.Mesh(backpackGeo, darkMat);
        backpack.position.set(0, 4.0, -1.8); 
        group.add(backpack);

        // æ§æç¾¤çµ„
        const gunGroup = new THREE.Group();
        gunGroup.position.set(-1.0, 5.0, -2.2); 
        gunGroup.rotation.x = -0.2; 
        group.add(gunGroup);

        // æ§ç®¡ (å•¡è‰²)
        const barrelGeo = new THREE.CylinderGeometry(0.3, 0.35, 6.0, 16);
        const barrel = new THREE.Mesh(barrelGeo, gunBarrelMat);
        barrel.position.y = 1.5;
        gunGroup.add(barrel);

        // æ§å£ (å•¡è‰²)
        const muzzleGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.8, 16);
        const muzzle = new THREE.Mesh(muzzleGeo, gunBarrelMat);
        muzzle.position.y = 4.5; 
        gunGroup.add(muzzle);

        // è¿½æ“Šå™¨/ç„æº–é¡ (æ·±é»ƒè‰²)
        const sensorGeo = new THREE.BoxGeometry(0.5, 1.0, 0.6);
        const sensor = new THREE.Mesh(sensorGeo, gunSensorMat);
        sensor.position.set(0, 1.0, 0.5); 
        gunGroup.add(sensor);

        return group;
    }

    // --- éŠæˆ²é‚è¼¯ ---

    function initGame() {
        initThreeJS();
        createGridMap();

        units = [];
        for (let id in unitMeshes) {
            scene.remove(unitMeshes[id]);
            const hp = document.getElementById(`hp-container-${id}`);
            if(hp) hp.remove();
        }
        unitMeshes = {};
        glowMeshes = [];
        
        turnCount = 1;
        document.getElementById('turn-count').innerText = 1;
        document.getElementById('log').innerHTML = '';
        
        document.getElementById('turn-text').innerText = "ç©å®¶å›åˆ";
        document.getElementById('turn-text').style.color = "#4da6ff";

        const btnEnd = document.getElementById('btn-end-turn');
        btnEnd.innerText = "çµæŸå›åˆ";
        btnEnd.style.backgroundColor = "#3d6aa8"; 
        btnEnd.style.borderColor = "#5588cc";
        btnEnd.disabled = false;

        log("--- ç©å®¶å›åˆ (Turn 1) ---", "system");

        selectedUnit = null;
        originalPos = null;
        currentTurn = TEAM_PLAYER;
        isDraggingMap = false;
        gameState = 'TRANSITION'; 

        const pY = BOARD_SIZE - 1;
        createUnit(TEAM_PLAYER, 0, pY);
        createUnit(TEAM_PLAYER, 1, pY);
        createUnit(TEAM_PLAYER, 2, pY);
        createUnit(TEAM_PLAYER, 0, pY - 1);
        createUnit(TEAM_PLAYER, 1, pY - 1);

        const eX = BOARD_SIZE - 1;
        createUnit(TEAM_ENEMY, eX, 0);
        createUnit(TEAM_ENEMY, eX - 1, 0);
        createUnit(TEAM_ENEMY, eX - 2, 0);
        createUnit(TEAM_ENEMY, eX, 1);
        createUnit(TEAM_ENEMY, eX - 1, 1);

        switchBGM('player');
        showTurnBanner("PLAYER PHASE", "#4da6ff", 'IDLE');
    }

    function createUnit(team, x, y) {
        let unit = {
            id: 'u_' + Math.random().toString(36).substr(2, 9),
            team: team, x: x, y: y, hp: UNIT_HP, maxHp: UNIT_HP, hasActed: false
        };
        units.push(unit);
        renderUnit3D(unit);
    }

    function renderUnit3D(unit) {
        if (unit.hp <= 0) {
            if (unitMeshes[unit.id]) { scene.remove(unitMeshes[unit.id]); delete unitMeshes[unit.id]; }
            const hpEl = document.getElementById(`hp-container-${unit.id}`); if(hpEl) hpEl.remove(); return; 
        }

        let mesh = unitMeshes[unit.id];
        const teamColor = unit.team === TEAM_PLAYER ? 0x4da6ff : 0xff4d4d;

        if (!mesh) {
            // [ä¿®æ”¹] å‚³å…¥ unit.team è®“å‡½å¼çŸ¥é“æ˜¯èª°ï¼Œæ±ºå®šå…‰åŠé¡è‰²
            mesh = createRobotModel(teamColor, unit.team);
            const pos = logicalToWorld(unit.x, unit.y);
            mesh.position.set(pos.x, pos.y, pos.z);
            
            // åˆå§‹é¢å‘
            if (unit.team === TEAM_PLAYER) {
                mesh.rotation.y = Math.PI; 
            } else {
                mesh.rotation.y = 0;
            }

            scene.add(mesh);
            unitMeshes[unit.id] = mesh;
            createHPBar(unit);
        }

        const targetColor = unit.hasActed ? 0x555555 : teamColor;
        
        mesh.traverse((child) => {
            if (child.isMesh && child.userData.isArmor) {
                child.material.color.setHex(targetColor);
            }
        });
        
        updateHPBar(unit);
    }

    function createHPBar(unit) {
        const container = document.createElement('div');
        container.className = 'overlay-label hp-overlay'; 
        container.id = `hp-container-${unit.id}`;
        container.style.display = isHPVisible ? 'block' : 'none'; 
        container.innerHTML = `<div class="hp-bar-container"><div class="hp-bar-fill" id="hp-fill-${unit.id}"></div></div>`;
        document.getElementById('overlay-container').appendChild(container);
    }

    function updateHPBar(unit) {
        const fillEl = document.getElementById(`hp-fill-${unit.id}`);
        if (!fillEl) return;
        const pct = Math.max(0, Math.min(100, (unit.hp / unit.maxHp) * 100));
        fillEl.style.width = pct + '%';
        if (pct > 50) fillEl.style.background = '#0f0';
        else if (pct > 20) fillEl.style.background = '#ff0';
        else fillEl.style.background = '#f00';
    }

    function animateHPChange(unit, oldHP, newHP) {
        const container = document.getElementById(`hp-container-${unit.id}`);
        const fillEl = document.getElementById(`hp-fill-${unit.id}`);
        if (!container || !fillEl) return;

        const oldPct = Math.max(0, Math.min(100, (oldHP / unit.maxHp) * 100));
        const newPct = Math.max(0, Math.min(100, (newHP / unit.maxHp) * 100));

        fillEl.style.transition = 'none';
        fillEl.style.width = oldPct + '%';
        
        if(container.hideTimer) clearTimeout(container.hideTimer);
        container.style.display = 'block';

        void fillEl.offsetWidth;

        fillEl.style.transition = 'width 0.5s ease-out';
        fillEl.style.width = newPct + '%';
        
        if (newPct > 50) fillEl.style.background = '#0f0';
        else if (newPct > 20) fillEl.style.background = '#ff0';
        else fillEl.style.background = '#f00';

        if (!isHPVisible) {
            container.hideTimer = setTimeout(() => {
                if (!isHPVisible) {
                    container.style.display = 'none';
                }
            }, 1500); 
        }
    }

    function moveUnit3D(unit, tx, ty) {
        return new Promise(resolve => {
            const mesh = unitMeshes[unit.id]; 
            const targetPos = logicalToWorld(tx, ty);

            // ç§»å‹•æ™‚é¢å‘ç›®æ¨™æ–¹å‘
            mesh.lookAt(targetPos.x, mesh.position.y, targetPos.z);

            // [ä¿®æ”¹] å¢åŠ æ–œå‘åˆ¤å®šæ¬Šé‡ï¼Œè®“ç§»å‹•æ™‚æ›´åƒæ˜¯åœ¨"èµ°"æ–œç·š (å¦‚æœæœ‰çš„è©±)
            const tl = gsap.timeline({ onComplete: () => { unit.x = tx; unit.y = ty; resolve(); }});
            tl.to(mesh.position, { x: targetPos.x, z: targetPos.z, y: targetPos.y, duration: 0.5, ease: "power2.inOut" });
        });
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        
        const time = Date.now() * 0.005;
        const opacity = 0.5 + Math.sin(time) * 0.15; 
        const scale = 1 + Math.sin(time) * 0.05;    
        
        glowMeshes.forEach(glow => {
            if(glow) {
                glow.material.opacity = opacity;
                glow.scale.set(scale, 1, scale); 
            }
        });

        units.forEach(u => {
            if (u.hp > 0 && unitMeshes[u.id]) {
                const screenPos = toScreenPosition(unitMeshes[u.id], 0, 30);
                const el = document.getElementById(`hp-container-${u.id}`);
                if (el) { el.style.left = screenPos.x + 'px'; el.style.top = screenPos.y + 'px'; }
            }
        });
        renderer.render(scene, camera);
    }

    function getUnitAt(x, y) { return units.find(u => u.x === x && u.y === y && u.hp > 0); }
    function getDistance(u1, u2) { return Math.abs(u1.x - u2.x) + Math.abs(u1.y - u2.y); }
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    function clearHighlights() {
        for(let y=0; y<BOARD_SIZE; y++) { for(let x=0; x<BOARD_SIZE; x++) {
                const mesh = gridMeshes[y][x];
                mesh.material.opacity = 0.0; 
                mesh.material.color.setHex(0x000000); 
        }}
    }

    function highlightGrid(x, y, type) {
        if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return;
        const mesh = gridMeshes[y][x];
        mesh.material.opacity = 0.5; 
        if (type === 'move') mesh.material.color.setHex(0x00aa00); 
        else if (type === 'attack') mesh.material.color.setHex(0xaa0000); 
        else if (type === 'range') mesh.material.color.setHex(0xcc8888); 
        else if (type === 'select') mesh.material.color.setHex(0xffff00); 
    }

    function handleCellClick(x, y) {
        if (gameState === 'TRANSITION' || gameState === 'AI_THINKING' || gameState === 'ANIMATING' || gameState === 'GAME_OVER') return;
        const clickedUnit = getUnitAt(x, y);
        if (gameState === 'ACTION_SELECT') {
            const hasMoved = (selectedUnit.x !== originalPos.x || selectedUnit.y !== originalPos.y);
            if (!hasMoved) { resetState(); return; }
        }
        if (gameState === 'IDLE') {
            if (clickedUnit && clickedUnit.team === TEAM_PLAYER && !clickedUnit.hasActed) { 
                playClick(); 
                openMenuForUnit(clickedUnit); 
            } 
            else if (clickedUnit) { 
                playClick(); 
                showUnitStats(clickedUnit); 
            }
            return;
        }
        if (gameState === 'MOVING') {
            if (x === selectedUnit.x && y === selectedUnit.y) { commitMove(x, y); return; }
            const mesh = gridMeshes[y][x];
            if (mesh.material.color.getHex() === 0x00aa00 && mesh.material.opacity > 0) { commitMove(x, y); } else { cancelMovePhase(); }
            return;
        }
        if (gameState === 'TARGETING') {
            const mesh = gridMeshes[y][x];
            if (mesh.material.color.getHex() === 0xaa0000 && mesh.material.opacity > 0 && clickedUnit && clickedUnit.team === TEAM_ENEMY) { executeAttack(selectedUnit, clickedUnit); } 
            else { backToActionMenu(); }
        }
    }

    function selectWeapon(type) {
        currentWeapon = type;
        gameState = 'TARGETING';
        document.getElementById('action-menu').style.display = 'none';
        const minR = type === 'melee' ? 1 : 2;
        const maxR = type === 'melee' ? 1 : 4;

        clearHighlights();
        highlightGrid(selectedUnit.x, selectedUnit.y, 'select');

        for (let dy = -maxR; dy <= maxR; dy++) {
            for (let dx = -maxR; dx <= maxR; dx++) {
                const dist = Math.abs(dx) + Math.abs(dy);
                if (dist >= minR && dist <= maxR) {
                    const tx = selectedUnit.x + dx;
                    const ty = selectedUnit.y + dy;
                    if (tx >= 0 && tx < BOARD_SIZE && ty >= 0 && ty < BOARD_SIZE) {
                        const target = getUnitAt(tx, ty);
                        if (target && target.team === TEAM_ENEMY) {
                            highlightGrid(tx, ty, 'attack'); 
                        } else {
                            highlightGrid(tx, ty, 'range'); 
                        }
                    }
                }
            }
        }
    }

    function openMenuForUnit(unit) {
        selectedUnit = unit; originalPos = { x: unit.x, y: unit.y }; gameState = 'ACTION_SELECT';
        clearHighlights(); highlightGrid(unit.x, unit.y, 'select'); showUnitStats(unit); updateMenuButtons(); showActionMenu3D(unit);
    }

    function activateMovePhase() {
        document.getElementById('action-menu').style.display = 'none'; gameState = 'MOVING'; const range = MOVE_RANGE;
        for (let dy = -range; dy <= range; dy++) { for (let dx = -range; dx <= range; dx++) {
                if (Math.abs(dx) + Math.abs(dy) > range) continue;
                let tx = selectedUnit.x + dx; let ty = selectedUnit.y + dy;
                if (tx >= 0 && tx < BOARD_SIZE && ty >= 0 && ty < BOARD_SIZE) {
                    if (!getUnitAt(tx, ty) || (tx === selectedUnit.x && ty === selectedUnit.y)) { highlightGrid(tx, ty, 'move'); }
                }
        }}
    }

    async function commitMove(x, y) {
        gameState = 'ANIMATING'; 
        await moveUnit3D(selectedUnit, x, y);
        gameState = 'ACTION_SELECT'; clearHighlights(); highlightGrid(x, y, 'select'); updateMenuButtons(); showActionMenu3D(selectedUnit);
    }

    function showActionMenu3D(unit) {
        const mesh = unitMeshes[unit.id]; const screenPos = toScreenPosition(mesh, 100, 0);
        const menu = document.getElementById('action-menu'); menu.style.display = 'block'; menu.style.opacity = '0';
        const menuHeight = menu.offsetHeight; let top = screenPos.y;
        if (top + menuHeight > window.innerHeight) top = window.innerHeight - menuHeight - 10; if (top < 0) top = 10;
        let left = screenPos.x; if (left + 200 > window.innerWidth) left = screenPos.x - 250;
        menu.style.left = left + 'px'; menu.style.top = top + 'px'; menu.style.opacity = '1';
    }

    function cancelMovePhase() { openMenuForUnit(selectedUnit); }
    async function cancelMove() {
        if (selectedUnit && originalPos) {
            selectedUnit.x = originalPos.x; selectedUnit.y = originalPos.y;
            const mesh = unitMeshes[selectedUnit.id]; const pos = logicalToWorld(originalPos.x, originalPos.y);
            mesh.position.set(pos.x, pos.y, pos.z); 
        } openMenuForUnit(selectedUnit);
    }

    function updateMenuButtons() {
        let hasMelee = false; let hasRange = false; const hasMoved = (selectedUnit.x !== originalPos.x || selectedUnit.y !== originalPos.y);
        units.forEach(target => {
            if (target.team !== TEAM_ENEMY || target.hp <= 0) return;
            const dist = getDistance(selectedUnit, target);
            if (dist === 1) hasMelee = true; if (dist >= 2 && dist <= 4) hasRange = true;
        });
        const btnMove = document.getElementById('btn-move'); const btnCancel = document.getElementById('btn-cancel');
        const btnMelee = document.getElementById('btn-melee'); const btnRange = document.getElementById('btn-range');
        if (hasMoved) { btnMove.disabled = true; btnCancel.style.display = 'block'; btnRange.disabled = true; } 
        else { btnMove.disabled = false; btnCancel.style.display = 'none'; btnRange.disabled = !hasRange; }
        btnMelee.disabled = !hasMelee;
    }

    function backToActionMenu() { gameState = 'ACTION_SELECT'; clearHighlights(); highlightGrid(selectedUnit.x, selectedUnit.y, 'select'); updateMenuButtons(); showActionMenu3D(selectedUnit); }
    
    async function performSingleAttack(source, target, weaponType, isCounter) {
        clearHighlights();
        let minDmg, maxDmg, minHit, maxHit, wName;
        if (weaponType === 'melee') { minDmg = 50; maxDmg = 70; minHit = 60; maxHit = 70; wName = "æ ¼é¬¥"; } 
        else { minDmg = 40; maxDmg = 60; minHit = 50; maxHit = 60; wName = "å°„æ“Š"; }
        let hitChance = Math.floor(Math.random() * (maxHit - minHit + 1)) + minHit;
        let isHit = Math.floor(Math.random() * 100) < hitChance;
        let damage = isHit ? Math.floor(Math.random() * (maxDmg - minDmg + 1)) + minDmg : 0;
        const teamName = source.team === TEAM_PLAYER ? 'æˆ‘æ–¹' : 'æ•µæ–¹'; const actionName = isCounter ? 'åæ“Š' : 'æ”»æ“Š'; const logStyle = isCounter ? 'log-counter' : 'normal';
        log(`${teamName} ${actionName} (${wName})! (å‘½ä¸­:${hitChance}%)`, logStyle);
        const sMesh = unitMeshes[source.id]; const tMesh = unitMeshes[target.id];

        // æ”»æ“Šæ™‚ï¼Œé›™æ–¹äº’ç›¸é¢å‘
        sMesh.lookAt(tMesh.position.x, sMesh.position.y, tMesh.position.z);
        tMesh.lookAt(sMesh.position.x, tMesh.position.y, sMesh.position.z);

        await sleep(200);
        if (weaponType === 'melee') {
            playSound(sfxAttack); showSwordIcon(source);
            const originalPos = sMesh.position.clone(); const targetPos = tMesh.position.clone();
            const lungePos = targetPos.clone().lerp(originalPos, 0.2); 
            await new Promise(r => { gsap.to(sMesh.position, { x: lungePos.x, z: lungePos.z, y: lungePos.y, duration: 0.15, yoyo: true, repeat: 1, onComplete: r }); });
        } else {
            playSound(sfxLaser); showLaser3D(sMesh.position, tMesh.position); await sleep(300);
        }
        if (isHit) {
            showPopup(target, "-" + damage, "damage"); gsap.to(tMesh.position, { x: "+=2", duration: 0.05, yoyo: true, repeat: 5 });
            await sleep(500); 
            
            const oldHP = target.hp;
            target.hp -= damage;
            animateHPChange(target, oldHP, target.hp);
            
            log(`å‘½ä¸­! å‚·å®³ <span class="log-damage">${damage}</span>`, 'normal'); 
        } else {
            showPopup(target, "MISS", "miss"); log(`MISS!`, 'log-miss'); await sleep(500);
        }
    }

    async function executeAttack(attacker, defender) {
        gameState = 'ANIMATING'; await performSingleAttack(attacker, defender, currentWeapon, false);
        if (defender.hp <= 0) { handleDeath(defender); } 
        else {
            const dist = getDistance(attacker, defender); let counterWeapon = null;
            if (dist === 1) counterWeapon = 'melee'; else if (dist >= 2 && dist <= 4) counterWeapon = 'range';
            if (counterWeapon) { await sleep(500); await performSingleAttack(defender, attacker, counterWeapon, true); if (attacker.hp <= 0) handleDeath(attacker); } 
            else { log("è·é›¢éé ï¼Œç„¡æ³•åæ“Šã€‚", "normal"); }
        } finishAction();
    }

    function showLaser3D(start, end) {
        const material = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 3 });
        const points = []; points.push(new THREE.Vector3(start.x, start.y + 2, start.z)); points.push(new THREE.Vector3(end.x, end.y + 2, end.z));
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        scene.add(line); setTimeout(() => scene.remove(line), 200);
    }

    function showPopup(unit, text, type) {
        const mesh = unitMeshes[unit.id]; const screenPos = toScreenPosition(mesh, 0, -30);
        const el = document.createElement('div'); el.className = type === 'damage' ? 'damage-popup overlay-label' : 'miss-popup overlay-label';
        el.innerText = text; el.style.left = screenPos.x + 'px'; el.style.top = screenPos.y + 'px';
        document.getElementById('overlay-container').appendChild(el); setTimeout(() => el.remove(), 1000);
    }

    function showSwordIcon(unit) {
        const mesh = unitMeshes[unit.id]; const screenPos = toScreenPosition(mesh, 0, -40);
        const el = document.createElement('div'); el.className = 'sword-icon-popup overlay-label'; el.innerText = "âš”ï¸";
        el.style.left = screenPos.x + 'px'; el.style.top = screenPos.y + 'px';
        document.getElementById('overlay-container').appendChild(el); setTimeout(() => el.remove(), 600);
    }

    function triggerExplosion(unit) {
        const mesh = unitMeshes[unit.id]; const pos = mesh.position;
        const particleGeo = new THREE.BoxGeometry(1, 1, 1); const particleMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        for(let i=0; i<20; i++) {
            const p = new THREE.Mesh(particleGeo, particleMat); p.position.copy(pos); scene.add(p);
            gsap.to(p.position, { x: pos.x + (Math.random()-0.5)*30, y: pos.y + (Math.random()-0.5)*30, z: pos.z + (Math.random()-0.5)*30, duration: 0.8, onComplete: () => scene.remove(p) });
            gsap.to(p.scale, { x: 0, y: 0, z: 0, duration: 0.8 });
        }
    }

    function handleDeath(unit) {
        triggerExplosion(unit); playSound(sfxExplosion); const mesh = unitMeshes[unit.id]; scene.remove(mesh); delete unitMeshes[unit.id];
        const hpEl = document.getElementById(`hp-container-${unit.id}`); if(hpEl) hpEl.remove(); log(`*** æ“Šå¢œ ***`, 'log-damage'); checkWinCondition(); 
    }

    function waitAction() { finishAction(); }
    function finishAction() { if (selectedUnit && selectedUnit.hp > 0) { selectedUnit.hasActed = true; renderUnit3D(selectedUnit); } resetState(); }
    function resetState() {
        if (gameState === 'GAME_OVER') return;
        if (currentTurn === TEAM_ENEMY) gameState = 'AI_THINKING'; else gameState = 'IDLE';
        selectedUnit = null; originalPos = null; clearHighlights();
        document.getElementById('action-menu').style.display = 'none'; document.getElementById('stats-content').innerHTML = 'è«‹é¸æ“‡æ©Ÿé«”';
    }

    function showTurnBanner(text, color, nextState) {
        gameState = 'TRANSITION'; document.getElementById('action-menu').style.display = 'none'; clearHighlights();
        const banner = document.getElementById('turn-banner'); banner.innerText = text; banner.style.color = color; banner.style.borderTopColor = color; banner.style.borderBottomColor = color;
        banner.style.left = '0%';
        setTimeout(() => { banner.style.left = '100%';
            setTimeout(() => { banner.style.transition = 'none'; banner.style.left = '-100%';
                setTimeout(() => { banner.style.transition = 'left 0.5s ease-out'; gameState = nextState; if (gameState === 'AI_THINKING') runAITurn(); }, 50);
            }, 500);
        }, 1500);
    }

    function endTurn() {
        if (gameState !== 'IDLE') return; if (selectedUnit) cancelMove();
        currentTurn = TEAM_ENEMY; 
        
        const turnText = document.getElementById('turn-text');
        turnText.innerText = "æ•µæ–¹å›åˆ";
        turnText.style.color = "#ff4d4d";

        const btnEnd = document.getElementById('btn-end-turn');
        btnEnd.innerText = "æ•µæ–¹å›åˆä¸­";
        btnEnd.style.backgroundColor = "#4a0a0a"; 
        btnEnd.style.borderColor = "#662222";
        btnEnd.disabled = true;

        units.filter(u => u.team === TEAM_PLAYER).forEach(u => { u.hasActed = false; renderUnit3D(u); });
        
        log("--- æ•µæ–¹å›åˆ ---", "system");
        switchBGM('enemy'); showTurnBanner("ENEMY PHASE", "#ff4d4d", 'AI_THINKING');
    }

    function startPlayerTurn() {
        currentTurn = TEAM_PLAYER; turnCount++; document.getElementById('turn-count').innerText = turnCount; 
        
        const turnText = document.getElementById('turn-text');
        turnText.innerText = "ç©å®¶å›åˆ"; 
        turnText.style.color = "#4da6ff"; 
        
        const btnEnd = document.getElementById('btn-end-turn');
        btnEnd.innerText = "çµæŸå›åˆ";
        btnEnd.style.backgroundColor = "#3d6aa8"; 
        btnEnd.style.borderColor = "#5588cc";
        btnEnd.disabled = false;

        units.filter(u => u.team === TEAM_ENEMY).forEach(u => { u.hasActed = false; renderUnit3D(u); });
        log(`--- ç©å®¶å›åˆ (Turn ${turnCount}) ---`, "system");
        switchBGM('player'); showTurnBanner("PLAYER PHASE", "#4da6ff", 'IDLE');
    }

    async function runAITurn() {
        const enemies = units.filter(u => u.team === TEAM_ENEMY && u.hp > 0);
        for (const enemy of enemies) {
            if (gameState === 'GAME_OVER') return; showUnitStats(enemy); await sleep(600); 
            let target = null; let minDist = 9999; const players = units.filter(u => u.team === TEAM_PLAYER && u.hp > 0);
            if (players.length === 0) break; players.forEach(p => { const d = getDistance(enemy, p); if (d < minDist) { minDist = d; target = p; } });
            let dist = getDistance(enemy, target);
            if (dist >= 2 && dist <= 4) { selectedUnit = enemy; currentWeapon = 'range'; await executeAttack(enemy, target); continue; }
            let bestX = enemy.x, bestY = enemy.y; let minMoveDist = 9999;
            for (let dy = -MOVE_RANGE; dy <= MOVE_RANGE; dy++) { for (let dx = -MOVE_RANGE; dx <= MOVE_RANGE; dx++) {
                    if (Math.abs(dx) + Math.abs(dy) > MOVE_RANGE) continue;
                    let tx = enemy.x + dx; let ty = enemy.y + dy;
                    if (tx < 0 || tx >= BOARD_SIZE || ty < 0 || ty >= BOARD_SIZE) continue;
                    if (getUnitAt(tx, ty) && (tx!==enemy.x || ty!==enemy.y)) continue;
                    let distToTarget = Math.abs(tx - target.x) + Math.abs(ty - target.y); 
                    // å„ªå…ˆç›®æ¨™: è·é›¢ç›®æ¨™å°„ç¨‹1æ ¼
                    let score = Math.abs(distToTarget - 1); 
                    
                    // æ¬¡è¦ç›®æ¨™: å„ªå…ˆæ–œè¡Œ (Tie-breaker)
                    let dxMove = Math.abs(tx - enemy.x);
                    let dyMove = Math.abs(ty - enemy.y);
                    score -= Math.min(dxMove, dyMove) * 0.01;

                    if (score < minMoveDist) { minMoveDist = score; bestX = tx; bestY = ty; }
            }}
            selectedUnit = enemy; gameState = 'ANIMATING'; await moveUnit3D(enemy, bestX, bestY); await sleep(200);
            let newDist = getDistance(enemy, target);
            if (newDist === 1) { currentWeapon = 'melee'; await executeAttack(enemy, target); } else { enemy.hasActed = true; renderUnit3D(enemy); }
        }
        if (gameState !== 'GAME_OVER') { await sleep(500); startPlayerTurn(); }
    }

    function checkWinCondition() {
        const players = units.filter(u => u.team === TEAM_PLAYER && u.hp > 0); const enemies = units.filter(u => u.team === TEAM_ENEMY && u.hp > 0);
        let msg = "", isOver = false; if (enemies.length === 0) { msg = "VICTORY! æ•µè»å…¨æ»…ï¼"; isOver = true; } else if (players.length === 0) { msg = "DEFEAT... æˆ‘è»å…¨æ»…ã€‚"; isOver = true; }
        if (isOver) {
            gameState = 'GAME_OVER'; switchBGM(null); document.getElementById('turn-indicator').style.display = 'none'; document.getElementById('btn-end-turn').style.display = 'none'; document.getElementById('btn-restart').style.display = 'block';
            log(`=== ${msg} ===`, 'log-system'); const banner = document.getElementById('turn-banner');
            banner.innerText = msg; banner.style.color = enemies.length === 0 ? "#4da6ff" : "#ff4d4d"; banner.style.left = '0%'; return true;
        } return false;
    }
    function restartGame() { 
        document.getElementById('turn-indicator').style.display = 'block';
        document.getElementById('btn-end-turn').style.display = 'block';
        document.getElementById('btn-restart').style.display = 'none';
        
        const banner = document.getElementById('turn-banner'); 
        banner.style.left = '-100%'; 
        initGame(); 
    }
    function log(msg, type) {
        const logEl = document.getElementById('log'); const entry = document.createElement('div');
        entry.className = `log-entry ${type === 'system' ? 'log-system' : ''} ${type === 'log-miss' ? 'log-miss' : ''} ${type === 'log-counter' ? 'log-counter' : ''}`;
        entry.innerHTML = msg; logEl.appendChild(entry); logEl.scrollTop = logEl.scrollHeight;
    }
    function showUnitStats(unit) {
        const el = document.getElementById('stats-content'); const color = unit.team === TEAM_PLAYER ? '#4da6ff' : '#ff4d4d'; const name = unit.team === TEAM_PLAYER ? 'æˆ‘æ–¹æ©Ÿé«” (P)' : 'æ•µæ–¹æ©Ÿé«” (E)';
        el.innerHTML = `<div style="color:${color};font-size:18px;font-weight:bold;">${name}</div><div style="font-size:16px; margin: 5px 0;">HP: <span style="color:${unit.hp<40?'red':'white'}">${unit.hp}</span> / ${unit.maxHp}</div><div style="color:#aaa;">ä½ç½®: (${unit.x}, ${unit.y})</div><div style="color:#aaa;">ç‹€æ…‹: ${unit.hasActed ? 'å·²è¡Œå‹•' : 'æœªè¡Œå‹•'}</div>`;
    }

    initGame(); 
</script>

</body>
</html>